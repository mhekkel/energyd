//          Copyright Maarten L. Hekkelman, 2019
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#pragma once

#include <cassert>
#include <memory>
#include <istream>

#include <zeep/xml/unicode_support.hpp>
#include <zeep/exception.hpp>

namespace zeep
{
namespace detail
{

using xml::unicode;
using xml::encoding_type;

// --------------------------------------------------------------------

template <typename T>
struct value_saver
{
	T& m_ref;
	T m_value;

	value_saver(T& value, const T& new_value) : m_ref(value), m_value(value) { m_ref = new_value; }
	~value_saver() { m_ref = m_value; }
};

class mini_stack
{
public:
	mini_stack() : m_ix(-1) {}

	unicode top()
	{
		assert(m_ix >= 0 and m_ix < int(sizeof(m_data) / sizeof(unicode)));
		return m_data[m_ix];
	}

	void pop()
	{
		--m_ix;
	}

	void push(unicode uc)
	{
		++m_ix;
		assert(m_ix < int(sizeof(m_data) / sizeof(unicode)));
		m_data[m_ix] = uc;
	}

	bool empty() const
	{
		return m_ix == -1;
	}

private:
	unicode m_data[2];
	int m_ix;
};

bool is_absolute_path(const std::string& s);

// parsing XML is somewhat like macro processing,
// we can encounter entities that need to be expanded into replacement text
// and so we declare data_source objects that can be stacked.

class data_source;

// exception generated by data_source

class source_exception : public zeep::exception
{
public:
	source_exception(const std::string& msg) : exception(msg), m_wmsg(msg) {}
	~source_exception() throw() {}

	std::string m_wmsg;
};

// A data source can have a base dir which is the directory the data came from.
// This information is needed when a relative uri is found in an external ID.

class data_source
{
public:
	data_source(data_source *next)
		: m_next(next), m_base("."), m_encoding(encoding_type::enc_UTF8), m_line_nr(1)
	{
		static int sNextID = 0;
		m_id = sNextID++;
	}

	virtual ~data_source() {}

	// data_source is a virtual base class. Derivatives need to declare the next function.
	virtual unicode get_next_char() = 0;

	// to avoid recursively nested entity values, we have a check:
	virtual bool is_entity_on_stack(const std::string& name)
	{
		bool result = false;
		if (m_next != nullptr)
			result = m_next->is_entity_on_stack(name);
		return result;
	}

	void base(const std::string& dir) { m_base = dir; }
	const std::string& base() const { return m_base; }

	virtual bool auto_discard() const { return false; }

	data_source *next_data_source() const { return m_next; }

	encoding_type encoding() const { return m_encoding; }

	int id() const { return m_id; }

	int get_line_nr() const { return m_line_nr; }

protected:
	data_source(const data_source &);
	data_source& operator=(const data_source &);

	data_source *m_next; // generates a linked list of data_sources
	std::string m_base;
	encoding_type m_encoding;
	int m_id;	  // for nesting checks
	int m_line_nr; // for reporting errors
};

// --------------------------------------------------------------------
// An std::istream implementation of data_source.

class istream_data_source : public data_source
{
public:
	istream_data_source(std::istream& data, data_source *next = nullptr)
		: data_source(next), m_data(data), m_char_buffer(0), m_has_bom(false)
	{
		guess_encoding();
	}

	istream_data_source(std::istream *data, data_source *next = nullptr)
		: data_source(next), m_data(*data), m_data_ptr(data), m_char_buffer(0), m_has_bom(false)
	{
		guess_encoding();
	}

	bool has_bom() { return m_has_bom; }

private:
	void guess_encoding();

	void parse_text_decl();

	virtual unicode get_next_char();

	unicode next_utf8_char();

	unicode next_utf16le_char();

	unicode next_utf16be_char();

	unicode next_iso88591_char();

	unsigned char next_byte();

	std::istream& m_data;
	std::unique_ptr<std::istream>
		m_data_ptr;
	unicode m_char_buffer; // used in detecting \r\n algorithm

	typedef unicode (istream_data_source::*next_func)(void);

	next_func m_next;
	bool m_has_bom;
};

inline unsigned char istream_data_source::next_byte()
{
	int result = m_data.rdbuf()->sbumpc();

	if (result == std::streambuf::traits_type::eof())
		result = 0;

	return static_cast<unsigned char>(result);
}

// --------------------------------------------------------------------

class string_data_source : public data_source
{
public:
	string_data_source(const std::string& data, data_source *next = nullptr)
		: data_source(next), m_data(data), m_ptr(m_data.begin())
	{
	}

private:
	virtual unicode get_next_char();

	std::string m_data;
	std::string::iterator m_ptr;
};

}
}